<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>404 ‚Äî Game Time Not Found</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

  body {
    margin: 0;
    background: linear-gradient(135deg, #0a122b 0%, #141c3e 100%);
    color: #e3e8f0;
    font-family: 'Inter', sans-serif;
    display: flex;
    height: 100vh;
  }
  .sidebar {
    width: 220px;
    background: #1b2245;
    padding: 1rem 0.5rem;
    display: flex;
    flex-direction: column;
    box-shadow: 4px 0 10px rgba(0,0,0,0.6);
  }
  .sidebar h2 {
    font-weight: 700;
    font-size: 1.4rem;
    padding-left: 1rem;
    margin-bottom: 1rem;
    color: #f5d76e;
  }
  .game-btn {
    background: none;
    border: none;
    color: #cbd2f0;
    text-align: left;
    padding: 0.7rem 1rem;
    margin: 0.1rem 0;
    font-size: 1rem;
    cursor: pointer;
    border-left: 4px solid transparent;
    transition: background-color 0.2s, border-color 0.3s;
  }
  .game-btn:hover {
    background-color: #2c356d;
  }
  .game-btn.active {
    background-color: #343e8a;
    border-left: 4px solid #f5d76e;
    color: #fff;
    font-weight: 700;
  }

  .main-content {
    flex: 1;
    padding: 2rem;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
  }
  h1 {
    margin: 0 0 0.4rem 0;
    font-weight: 700;
    font-size: 2.5rem;
    color: #f5d76e;
  }
  p.instructions {
    margin: 0 0 1.5rem 0;
    font-weight: 400;
    line-height: 1.4;
    max-width: 600px;
  }
  .game-container {
    flex: 1;
    background: #141c3e;
    border-radius: 12px;
    box-shadow: inset 0 0 20px rgba(0,0,0,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  canvas, iframe {
    border-radius: 10px;
    background: #0f142d;
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    max-width: 100%;
    max-height: 100%;
  }
  iframe {
    width: 600px;
    height: 360px;
    border: none;
  }
  canvas {
    width: 600px;
    height: 360px;
  }
</style>
</head>
<body>
  <nav class="sidebar" aria-label="Game selector">
    <h2>Choose a Game</h2>
    <button class="game-btn active" data-game="snake" aria-current="page">üêç Snake</button>
    <button class="game-btn" data-game="flappy">üê¶ Flappy Bird</button>
    <button class="game-btn" data-game="dino">ü¶ñ Google Dino</button>
    <button class="game-btn" data-game="tictactoe">‚≠ï Tic Tac Toe</button>
    <button class="game-btn" data-game="game2048">üî¢ 2048</button>
  </nav>

  <main class="main-content" role="main" aria-live="polite">
    <h1>404 ‚Äî Game Time Not Found</h1>
    <p class="instructions">Oops! The page you wanted is hiding. While we find it, why not play one of these games? Select a game from the menu to start playing.</p>
    <section class="game-container" aria-label="Game display area">
      <!-- Snake Canvas -->
      <canvas id="snake" width="600" height="360" style="display:block;"></canvas>
      <!-- Flappy Bird Canvas -->
      <canvas id="flappy" width="600" height="360" style="display:none;"></canvas>
      <!-- Google Dino Canvas -->
      <canvas id="dino" width="600" height="360" style="display:none;"></canvas>
      <!-- Tic Tac Toe Canvas -->
      <canvas id="tictactoe" width="600" height="360" style="display:none;"></canvas>
        <!-- 2048 Canvas -->
      <canvas id="game2048" width="600" height="360" style="display:none;"></canvas>
    </section>
  </main>

<script>
  // Game selector logic
  const buttons = document.querySelectorAll('.game-btn');
  const snakeCanvas = document.getElementById('snake');
  const flappyCanvas = document.getElementById('flappy');
  const dinoCanvas = document.getElementById('dino');
  const tttCanvas = document.getElementById('tictactoe');

  function hideAllGames() {
    snakeCanvas.style.display = 'none';
    flappyCanvas.style.display = 'none';
    dinoCanvas.style.display = 'none';
    tttCanvas.style.display = 'none';
  }

  function setActiveButton(game) {
    buttons.forEach(btn => {
      if (btn.dataset.game === game) {
        btn.classList.add('active');
        btn.setAttribute('aria-current', 'page');
      } else {
        btn.classList.remove('active');
        btn.removeAttribute('aria-current');
      }
    });
  }

  function showGame(game) {
    hideAllGames();
    setActiveButton(game);
    switch(game) {
      case 'snake': snakeCanvas.style.display = 'block'; break;
      case 'flappy': flappyCanvas.style.display = 'block'; break;
      case 'dino': dinoCanvas.style.display = 'block'; break;
      case 'tictactoe': tttCanvas.style.display = 'block'; break;
      case 'game2048': canvas2048.style.display = 'block'; break;
    }
  }

  buttons.forEach(btn => {
    btn.addEventListener('click', () => {
      showGame(btn.dataset.game);
    });
  });

  // Initialize with snake visible
  showGame('snake');

  // ==========================
  // Snake Game Implementation
  // ==========================
  const snakeCtx = snakeCanvas.getContext('2d');
  const grid = 20;
  let snake = [{x: 8 * grid, y: 9 * grid}];
  let snakeDir = {x: 1, y: 0};
  let food = {x: 0, y: 0};

  function randomFood() {
    food.x = Math.floor(Math.random() * (snakeCanvas.width / grid)) * grid;
    food.y = Math.floor(Math.random() * (snakeCanvas.height / grid)) * grid;
  }

  function drawSnake() {
    snakeCtx.fillStyle = '#a1e44d';
    snake.forEach(seg => {
      snakeCtx.fillRect(seg.x, seg.y, grid - 2, grid - 2);
    });
  }

  function drawFood() {
    snakeCtx.fillStyle = '#e44d4d';
    snakeCtx.fillRect(food.x, food.y, grid - 2, grid - 2);
  }

  function moveSnake() {
    let head = {x: snake[0].x + snakeDir.x * grid, y: snake[0].y + snakeDir.y * grid};

    if (head.x < 0) head.x = snakeCanvas.width - grid;
    if (head.x >= snakeCanvas.width) head.x = 0;
    if (head.y < 0) head.y = snakeCanvas.height - grid;
    if (head.y >= snakeCanvas.height) head.y = 0;

    // Check collision with self
    if (snake.some(s => s.x === head.x && s.y === head.y)) {
      snake = [{x: 8 * grid, y: 9 * grid}];
      snakeDir = {x: 1, y: 0};
      randomFood();
      return;
    }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      randomFood();
    } else {
      snake.pop();
    }
  }

  function gameLoopSnake() {
    snakeCtx.clearRect(0, 0, snakeCanvas.width, snakeCanvas.height);
    moveSnake();
    drawSnake();
    drawFood();
  }
  randomFood();
  setInterval(() => {
    if (snakeCanvas.style.display === 'block') gameLoopSnake();
  }, 120);

  window.addEventListener('keydown', e => {
    if (snakeCanvas.style.display !== 'block') return;
    if (e.key === 'ArrowUp' && snakeDir.y === 0) snakeDir = {x: 0, y: -1};
    if (e.key === 'ArrowDown' && snakeDir.y === 0) snakeDir = {x: 0, y: 1};
    if (e.key === 'ArrowLeft' && snakeDir.x === 0) snakeDir = {x: -1, y: 0};
    if (e.key === 'ArrowRight' && snakeDir.x === 0) snakeDir = {x: 1, y: 0};
  });

  // ==========================
  // Flappy Bird (Simplified)
  // ==========================
  const flappyCtx = flappyCanvas.getContext('2d');
  let bird = {x: 50, y: 180, vy: 0, width: 30, height: 22};
  let gravity = 0.7;
  let pipes = [];
  let frameCount = 0;
  let flappyGameOver = false;

  function resetFlappy() {
    bird.y = 180; bird.vy = 0; pipes = [];
    frameCount = 0; flappyGameOver = false;
  }

  function drawBird() {
    flappyCtx.fillStyle = '#ffd700';
    flappyCtx.fillRect(bird.x, bird.y, bird.width, bird.height);
  }

  function drawPipes() {
    flappyCtx.fillStyle = '#228b22';
    pipes.forEach(pipe => {
      flappyCtx.fillRect(pipe.x, 0, pipe.width, pipe.top);
      flappyCtx.fillRect(pipe.x, pipe.bottom, pipe.width, flappyCanvas.height - pipe.bottom);
    });
  }

  function updatePipes() {
    if (frameCount % 90 === 0) {
      let topHeight = Math.random() * 120 + 40;
      pipes.push({x: flappyCanvas.width, width: 40, top: topHeight, bottom: topHeight + 130});
    }
    pipes.forEach(pipe => pipe.x -= 3);
    pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);
  }

  function checkCollisionFlappy() {
    if (bird.y + bird.height > flappyCanvas.height || bird.y < 0) return true;
    for (let pipe of pipes) {
      if (bird.x + bird.width > pipe.x && bird.x < pipe.x + pipe.width) {
        if (bird.y < pipe.top || bird.y + bird.height > pipe.bottom) return true;
      }
    }
    return false;
  }

  function gameLoopFlappy() {
    if (flappyCanvas.style.display !== 'block') return;
    flappyCtx.clearRect(0, 0, flappyCanvas.width, flappyCanvas.height);
    bird.vy += gravity;
    bird.y += bird.vy;
    updatePipes();
    drawPipes();
    drawBird();

    if (checkCollisionFlappy()) {
      flappyGameOver = true;
      resetFlappy();
    }
    frameCount++;
  }

  flappyCanvas.addEventListener('click', () => {
    if (flappyCanvas.style.display === 'block') bird.vy = -10;
  });

  setInterval(() => {
    if (flappyCanvas.style.display === 'block') gameLoopFlappy();
  }, 30);

  // ==========================
  // Google Dino (Simplified)
  // ==========================
  const dinoCtx = dinoCanvas.getContext('2d');
  let dino = {x: 50, y: 310, vy: 0, width: 40, height: 40, jumping: false};
  let dinoGravity = 1.2;
  let obstacles = [];
  let dinoFrameCount = 0;
  let dinoGameOver = false;

  function resetDino() {
    dino.y = 310; dino.vy = 0; obstacles = [];
    dinoFrameCount = 0; dinoGameOver = false;
  }

  function drawDino() {
    dinoCtx.fillStyle = '#eecc55';
    dinoCtx.fillRect(dino.x, dino.y, dino.width, dino.height);
  }

  function drawObstacles() {
    dinoCtx.fillStyle = '#a44d4d';
    obstacles.forEach(obs => {
      dinoCtx.fillRect(obs.x, obs.y, obs.width, obs.height);
    });
  }

  function updateObstacles() {
    if (dinoFrameCount % 90 === 0) {
      obstacles.push({x: dinoCanvas.width, y: 350, width: 20, height: 40});
    }
    obstacles.forEach(obs => obs.x -= 5);
    obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
  }

  function checkCollisionDino() {
    for (let obs of obstacles) {
      if (dino.x < obs.x + obs.width && dino.x + dino.width > obs.x &&
          dino.y < obs.y + obs.height && dino.y + dino.height > obs.y) {
        return true;
      }
    }
    return false;
  }

  function gameLoopDino() {
    if (dinoCanvas.style.display !== 'block') return;
    dinoCtx.clearRect(0, 0, dinoCanvas.width, dinoCanvas.height);

    if (dino.jumping) {
      dino.vy -= dinoGravity;
      dino.y -= dino.vy;
      if (dino.y >= 310) {
        dino.y = 310;
        dino.jumping = false;
        dino.vy = 0;
      }
    }

    updateObstacles();
    drawObstacles();
    drawDino();

    if (checkCollisionDino()) {
      dinoGameOver = true;
      resetDino();
    }
    dinoFrameCount++;
  }

  dinoCanvas.addEventListener('click', () => {
    if (dinoCanvas.style.display === 'block' && !dino.jumping) {
      dino.jumping = true;
      dino.vy = 20;
    }
  });

  setInterval(() => {
    if (dinoCanvas.style.display === 'block') gameLoopDino();
  }, 30);

  // ==========================
  // Tic Tac Toe
  // ==========================
  const tttCtx = tttCanvas.getContext('2d');
  let board = Array(9).fill(null);
  let currentPlayer = 'X';
  let tttGameOver = false;

  function drawTTTBoard() {
    tttCtx.clearRect(0, 0, tttCanvas.width, tttCanvas.height);
    tttCtx.strokeStyle = '#e3e8f0';
    tttCtx.lineWidth = 4;

    // Draw grid lines
    const size = 120;
    for (let i = 1; i <= 2; i++) {
      tttCtx.beginPath();
      tttCtx.moveTo(i * size, 0);
      tttCtx.lineTo(i * size, size * 3);
      tttCtx.stroke();

      tttCtx.beginPath();
      tttCtx.moveTo(0, i * size);
      tttCtx.lineTo(size * 3, i * size);
      tttCtx.stroke();
    }

    // Draw marks
    tttCtx.font = 'bold 100px Inter, sans-serif';
    tttCtx.textAlign = 'center';
    tttCtx.textBaseline = 'middle';

    for (let i = 0; i < 9; i++) {
      if (board[i]) {
        tttCtx.fillStyle = board[i] === 'X' ? '#f5d76e' : '#a1e44d';
        tttCtx.fillText(board[i], (i % 3) * size + size/2, Math.floor(i / 3) * size + size/2 + 5);
      }
    }
  }

  function checkWinner() {
    const wins = [
      [0,1,2], [3,4,5], [6,7,8],
      [0,3,6], [1,4,7], [2,5,8],
      [0,4,8], [2,4,6]
    ];
    for (let combo of wins) {
      const [a,b,c] = combo;
      if (board[a] && board[a] === board[b] && board[a] === board[c]) {
        return board[a];
      }
    }
    if (!board.includes(null)) return 'Draw';
    return null;
  }

  function resetTTT() {
    board = Array(9).fill(null);
    currentPlayer = 'X';
    tttGameOver = false;
    drawTTTBoard();
  }

  tttCanvas.addEventListener('click', e => {
    if (tttCanvas.style.display !== 'block' || tttGameOver) return;
    const rect = tttCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const size = 120;
    const col = Math.floor(x / size);
    const row = Math.floor(y / size);
    const index = row * 3 + col;
    if (board[index] === null) {
      board[index] = currentPlayer;
      const winner = checkWinner();
      if (winner) {
        tttGameOver = true;
        setTimeout(() => alert(winner === 'Draw' ? "It's a draw!" : `${winner} wins!`), 100);
      } else {
        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
      }
      drawTTTBoard();
    }
  });
    // ==========================
    // 2048 Game
    // ==========================
    const canvas2048 = document.getElementById('game2048');
    const ctx2048 = canvas2048.getContext('2d');
    const size2048 = 4;
    let grid2048 = [];
    let tileSize = 80;

    function reset2048() {
    grid2048 = Array(size2048).fill(null).map(() => Array(size2048).fill(0));
    addRandomTile();
    addRandomTile();
    }

    function addRandomTile() {
    let empty = [];
    for (let i = 0; i < size2048; i++) {
        for (let j = 0; j < size2048; j++) {
        if (grid2048[i][j] === 0) empty.push({i, j});
        }
    }
    if (empty.length === 0) return;
    const {i, j} = empty[Math.floor(Math.random() * empty.length)];
    grid2048[i][j] = Math.random() < 0.9 ? 2 : 4;
    }

    function draw2048() {
    ctx2048.clearRect(0, 0, canvas2048.width, canvas2048.height);
    ctx2048.fillStyle = '#141c3e';
    ctx2048.fillRect(0, 0, canvas2048.width, canvas2048.height);
    ctx2048.font = 'bold 40px Inter';
    ctx2048.textAlign = 'center';
    ctx2048.textBaseline = 'middle';

    for (let i = 0; i < size2048; i++) {
        for (let j = 0; j < size2048; j++) {
        const val = grid2048[i][j];
        ctx2048.fillStyle = val === 0 ? '#2c356d' : '#f5d76e';
        ctx2048.fillRect(j*tileSize + 30, i*tileSize + 30, tileSize-10, tileSize-10);
        if (val !== 0) {
            ctx2048.fillStyle = '#000';
            ctx2048.fillText(val, j*tileSize + 30 + tileSize/2 -5, i*tileSize + 30 + tileSize/2);
        }
        }
    }
    }

    function slide(row) {
    let arr = row.filter(val => val !== 0);
    for (let i = 0; i < arr.length-1; i++) {
        if (arr[i] === arr[i+1]) {
        arr[i] *= 2;
        arr[i+1] = 0;
        }
    }
    return arr.filter(val => val !== 0);
    }

    function move2048(dir) {
    let moved = false;
    let rotated = false;

    function rotateGrid() {
        let newGrid = Array(size2048).fill(null).map(() => Array(size2048).fill(0));
        for (let i = 0; i < size2048; i++) {
        for (let j = 0; j < size2048; j++) {
            newGrid[j][size2048-1-i] = grid2048[i][j];
        }
        }
        grid2048 = newGrid;
    }

    if (dir === 'up') { rotateGrid(); rotated = true; }
    if (dir === 'down') { rotateGrid(); rotateGrid(); rotateGrid(); rotated = true; }

    for (let i = 0; i < size2048; i++) {
        let original = [...grid2048[i]];
        let newRow = slide(grid2048[i]);
        while(newRow.length < size2048) newRow.push(0);
        grid2048[i] = newRow;
        if (!moved && original.toString() !== newRow.toString()) moved = true;
    }

    if (dir === 'up') { rotateGrid(); rotateGrid(); rotateGrid(); }
    if (dir === 'down') { rotateGrid(); }

    if (moved) addRandomTile();
    draw2048();
    }

    window.addEventListener('keydown', e => {
    if (canvas2048.style.display !== 'block') return;
    switch(e.key) {
        case 'ArrowUp': move2048('down'); break;
        case 'ArrowDown': move2048('up'); break;
        case 'ArrowLeft': move2048('left'); break;
        case 'ArrowRight': move2048('right'); break;
    }
    });

    reset2048();
    draw2048();


  resetTTT();
</script>
</body>
</html>
